local onebeta = {}
local oneteam = require('oneteam')
local https = require('ssl.https')
local url = require('socket.url')
local json = require('dkjson')

function onebeta:init()
    onebeta.commands = oneteam.commands(self.info.username):command('onebeta').table
    onebeta.help = '/onebeta - Allows you to select the firmware OneOS Beta information for your device.'
    onebeta.data = {}
    local jstr, res = https.request('https://beta.revtechs.me/nooneno/beta.json')
    if res == 200
    then
        onebeta.data = json.decode(jstr)
    end
    onebeta.devices = {}
    for k, v in pairs(onebeta.data.devices)
    do
        if k:lower():match('^mi')
        then
            if not onebeta.devices['MI']
            then
                onebeta.devices['MI'] = {}
            end
            table.insert(onebeta.devices['MI'], k)
        elseif k:lower():match('^redmi')
        then
            if not onebeta.devices['REDMI']
            then
                onebeta.devices['REDMI'] = {}
            end
            table.insert(onebeta.devices['REDMI'], k)
        elseif k:lower():match('^poco')
        then
            if not onebeta.devices['POCO']
            then
                onebeta.devices['POCO'] = {}
            end
            table.insert(onebeta.devices['POCO'], k)
        end
    end
end

function onebeta.get_info(input)
    local device = input
    local version = 'latest'
    if input:match('^.- .-$')
    then
        device = input:match('^(.-) ')
        version = input:match(' (.-)$')
    end
    local jstr, res = https.request(
        string.format(
            'https://beta.revtechs.me/nooneno/%s/%s/info.json',
            url.escape(device),
            url.escape(version)
        )
    )
    if res ~= 200 or jstr == '[]'
    then
        return false
    end
    return json.decode(jstr)
end

function onebeta:on_inline_query(inline_query, configuration, language)
    local input = oneteam.input(inline_query.query)
    if not input
    then
        return
    end
    local jdat = onebeta.get_info(input)
    if not jdat
    then
        return
    end
    return oneteam.answer_inline_query(
        inline_query.id,
        oneteam.inline_result()
        :type('article')
        :id(1)
        :title(jdat[1].device)
        :description('OneOS ' .. jdat[1].version)
        :input_message_content(
            oneteam.input_text_message_content(
                string.format(
                    language['onebeta']['1'],
                    jdat[1].device,
                    jdat[1].version,
                    jdat[1].testing == false
                    and utf8.char(10060)
                    or utf8.char(9989),
                    jdat[1].testing == false
                    and language['onebeta']['2']
                    or language['onebeta']['3']
                ),
                'html'
            )
        )
        :reply_markup(
            oneteam.inline_keyboard():row(
                oneteam.row():url_button(
                    jdat[1].filename,
                    jdat[1].url
                )
            )
        )
    )
end

function onebeta.get_model_keyboard(device)
    local keyboard = {
        ['inline_keyboard'] = {
            {}
        }
    }
    local total = 0
    for _, v in pairs(onebeta.devices[device])
    do
        total = total + 1
    end
    local count = 0
    local rows = math.floor(total / 999)
    if rows ~= total
    then
        rows = rows + 1
    end
    local row = 1
    for k, v in pairs(onebeta.data.devices)
    do
        if k:lower():match(
            device:lower():gsub(' ', '')
        )
        then
            count = count + 1
            if count == rows * row
            then
                row = row + 1
                table.insert(
                    keyboard.inline_keyboard,
                    {}
                )
            end
            table.insert(
                keyboard.inline_keyboard[row],
                {
                    ['text'] = v.name,
                    ['callback_data'] = 'onebeta:model:' .. k
                }
            )
        end
    end
    return keyboard
end

function onebeta.get_firmware_keyboard(model)
    local keyboard = {
        ['inline_keyboard'] = {
            {}
        }
    }
    local total = 0
    for _, v in pairs(onebeta.data.devices[model].firmwares)
    do
        total = total + 1
    end
    local count = 0
    local rows = math.floor(total / 999)
    if rows ~= total
    then
        rows = rows + 1
    end
    local row = 1
    for k, v in pairs(onebeta.data.devices[model].firmwares)
    do
        count = count + 1
        if count == rows * row
        then
            row = row + 1
            table.insert(
                keyboard.inline_keyboard,
                {}
            )
        end
        table.insert(
            keyboard.inline_keyboard[row],
            {
                ['text'] = v.version,
                ['callback_data'] = 'onebeta:firmware:' .. model .. ' ' .. v.buildid
            }
        )
    end
    return keyboard
end

function onebeta:on_callback_query(callback_query, message, configuration, language)
    if callback_query.data:match('^device%:')
    then
        callback_query.data = callback_query.data:match('^device%:(.-)$')
        return oneteam.edit_message_text(
            message.chat.id,
            message.message_id,
            language['onebeta']['4'],
            nil,
            true,
            onebeta.get_model_keyboard(callback_query.data)
        )
    elseif callback_query.data:match('^model%:')
    then
        callback_query.data = callback_query.data:match('^model%:(.-)$')
        return oneteam.edit_message_text(
            message.chat.id,
            message.message_id,
            language['onebeta']['5'],
            nil,
            true,
            onebeta.get_firmware_keyboard(callback_query.data)
        )
    elseif callback_query.data:match('^firmware%:')
    then
        local jdat = onebeta.get_info(
            callback_query.data:match('^firmware%:(.-)$')
        )
        return oneteam.edit_message_text(
            message.chat.id,
            message.message_id,
            string.format(
                language['onebeta']['1'],
                jdat[1].device,
                jdat[1].version,
                jdat[1].beta == false
                and utf8.char(10060)
                or utf8.char(9989),
                jdat[1].beta == false
                and language['onebeta']['2']
                or language['onebeta']['3']
            ),
            'html',
            true,
            oneteam.inline_keyboard():row(
                oneteam.row():url_button(
                    jdat[1].filename,
                    jdat[1].url
                )
            )
        )
    end
end

function onebeta:on_message(message, configuration, language)
    onebeta.init(self)
    return oneteam.send_message(
        message.chat.id,
        language['onebeta']['6'],
        nil,
        true,
        false,
        nil,
        oneteam.inline_keyboard()
        :row(
            oneteam.row()
            :callback_data_button(
                language['onebeta']['13'],
                'onebeta:device:MI'
            )
            :callback_data_button(
                language['onebeta']['14'],
                'onebeta:device:REDMI'
            )
        )
        :row(
            oneteam.row()
            :callback_data_button(
                language['onebeta']['11'],
                'onebeta:device:POCO'
            )
        )
    )
end

return onebeta
